apiVersion: "v1"
kind: "Service"
metadata:
  name: "redis-sentinel"
  namespace: "m2onk8s-littleman-co"
spec:
  ports:
  - port: 26379
    protocol: "TCP"
  selector:
    application: "redis-sentinel"
  sessionAffinity: "None"
  type: "ClusterIP"
---
apiVersion: "v1"
metadata:
  name: "redis-sentinel-data"
  namespace: "m2onk8s-littleman-co"
data:
  # In theory, it shouldn't really matter which redis note is used as the first
  # master. Once sentinel hits a node (any node, randomly) it will register
  # it as the master, and subsequent redis instances will query sentinel for the
  # master which will be the randomly elected note. Not sure if it will work
  # out that way, though.
  sentinel.conf: |
    sentinel monitor initial redis.m2onk8s-littleman-co.svc.cluster.local 6379 2
    sentinel down-after-milliseconds initial 60000
    sentinel failover-timeout initial 18000
    sentinel parallel-syncs initial 1
kind: "ConfigMap"
---
apiVersion: "extensions/v1beta1"
kind: "Deployment"
metadata:
  labels:
    appication: "redis"
  name: "redis-sentinel-deployment"
  namespace: "m2onk8s-littleman-co"
spec:
  # There must be a majority of sentinels to elect a master. It's either one
  # or three, so we're using 3 here (for H/A)
  # See http://redis.io/topics/sentinel
  replicas: 3
  selector:
    matchLabels:
      # Naming standard defined in https://docs.littleman.co/Kubernetes/
      application: "redis-sentinel"
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
    type: "RollingUpdate"
  template:
    metadata:
      labels:
        application: "redis-sentinel"
    spec:
      volumes:
        - name: "redis-sentinel-data"
          configMap:
            name: "redis-sentinel-data"
      containers:
      - image: "redis:3.0.7-alpine"
        imagePullPolicy: "IfNotPresent"
        name: "redis"
        args:
          - "redis-sentinel"
          - "/data/sentinel.conf"
        ports:
        - containerPort: 26379
          protocol: "TCP"
        volumeMounts:
          - name: "redis-sentinel-data"
            mountPath: "/data"
        resources: {}
        terminationMessagePath: "/dev/termination-log"
      restartPolicy: "Always"
